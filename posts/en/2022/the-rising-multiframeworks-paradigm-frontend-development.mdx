---
date: '2022-06-26'
cardImage: '/img/cogs.png'
title: 'The rise of multiframeworks paradigm in the frontend oss'
snippet: 'There is a rising trend of library developed in a multiframework and / or a framework agnostic paradigm in the frontend. This post acknowledge it and try to explore what it means for the future of frontend development.'
description: 'There is a rising trend of library developed in a multiframework and / or a framework agnostic paradigm in the frontend. This post acknowledge it and try to explore what it means for the future of frontend development.'
imagePath: '/img/cogs.png'
imageAlt: 'Cogs and coupling / decoupling'
imageWidth: '256'
imageHeight: '256'
category: 'General'
---

import { Tag } from '@chakra-ui/react'
import { PostIntro } from 'components'

# The rise of multiframeworks paradigm in the frontend oss

<PostIntro date='June 26th 2022' category='General' />

Over the last 10 years, we've seen a lot of new general purpose UI rendering libraries / frameworks being built:

- Angular (2010)
- React (2013)
- Vuejs (2014)
- Svelte (2016)
- SolidJS (2021)

Each one of these frameworks brought something new to the table but they are all at the core driven by the concept of UI components.
The frontend ecosystem experimented a lot on this concept of component.
Before them, most UI libraries were "Framework agnostic" as there were not much frameworks to go around.
But during the rise in usage of those new frameworks, the frontend javascript ecosystem explorations were tightly coupled with the underlying framework they were built for. For example:

- React: [React Select](https://react-select.com/home), [React Datepicker](https://reactdatepicker.com/)
- VueJS: [Vue Select](https://vue-select.org/), [Vue Datepicker](https://vue3datepicker.com/)

![tightly coupled](/img/tight-coupling-framework-lib.png)

A short while after the concept of [headless ui](https://www.merrickchristensen.com/articles/headless-user-interface-components/) got some traction.
A first this concept was very much applied within a framework specific context.
It was much more about building framework specific components flexible enought to easily evolve over time rather than building cross-frameworks libraries.
But it was a good reminder of the upsides of the separation of concerns in a UI building context. Something that, at the time was a bit forgotten about in favor tightly coupled components.

In parallel, the handling of the state of the component went throught a few iterations and explorations, from basic state utilities built in the frameworks,
to [observables](https://rxjs.dev/), [flux architecture implementation](https://redux.js.org/) and now [full blown state machines](https://xstate.js.org/), all built mainly outside of the frameworks themselves.

The combinaison of these two (headless ui and state handling outside of the UI framework) planted the seed for more decoupling to come in the frontend ecosystem.
Now in 2022, we've started to see quite a few "multiframeworks" libraries emerged and we are even starting to see a meta-framework go in that direction as well.
Some of libraries (the whole Tan stack for example) and framework (remix) started coupled with one framework before going the multiframework route, some other went built from the start in a multiframework way (Zag).
The most common pattern I've seen adopted to serve these multiframework is the [adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern).

![core-adapter-framework](/img/core-adapters-consumers.png)

## Decoupling at the library level

### UI logic utility

[Zagjs](https://zagjs.com/) is a UI components library based on finite state machines. It was built by the creator of [Chakra-UI](https://chakra-ui.com/), a React based UI kit that later built a VueJS version as well.
Zagjs is a fairly new library (still in 0.X as of August 2022) was built with multiframework support in mind from the start and as a core philosophy in order to resolve the issue the maintainer faced building UI components for multiframework before.
To quote them:

<Callout>
With the rise of design systems and component-driven development, there's an endless re-implementation of common component patterns (Tabs, Menu, Modal, etc.) in multiple frameworks.

Most of these implementations seem to be fairly similar in spirit, the differences being around the reactivity and effects systems for the framework (e.g. useState, useEffect in React.js). Framework specific solutions tend to grow in complexity over time and often become hard to understand, debug, improve or test.

</Callout>

- Zag (React, VueJS, SolidJS)

### UI kits

- Chakra UI
- Headless UI

### Multiframeworks components

Headless + Multiframework (React, Solid, Svelte, Vuejs)

Tan stack

- Query
- Table
- Virtual

AG grid

## Decoupling at the full stack meta framework level

- Remix

## What could this mean ?

- More decoupling -> more reusability
- Potential consolidation of the librarys around a few well supported multiframeworks libs
- Not being multiframeworks may end up being a big "con" in the future of frontend development
- May have some evolution in how we architect our frontend applications, maybe with a more "UI framework agnostic" architecture preference.
- UI frameworks may have less to do as their role will be more focus on UI orchestrations:
  - For example, using Remix make the developer write a lot less React code (less useEffect and others)
  - This could mean the same of others frameworks
